using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.IO;
using System.Windows.Forms;

using ICSharpCode.TextEditor.Document;
using ICSharpCode.TextEditor;
using System.Reflection;

namespace NPad
{
  /// <summary>
  /// Description of MainForm.
  /// </summary>
  public partial class MainForm : Form
  {
    mutable nemerlePath : string;
  
    isDirty : bool 
    { 
      mutable _isDirty : bool;
      get {_isDirty}; 
      set {_isDirty = value; updateTitle()} 
    }

    currentFileName : string 
    { 
      mutable _currentFileName : string;
      get {_currentFileName}; 
      set {_currentFileName = value; updateTitle()} 
    }
    
    public this()
    {
      InitializeComponent();

      initCompiler();
      initEditor();
      initFileBrowser();
      initToolbarAndMenu();
    }

    #region Event system
    subscribers : Dictionary[object, List[ToolStripItem]] = Dictionary();
    subscribe(item : ToolStripItem, action : void -> void) : void
    {
      item.Click += fun(_, _) { action() } 

      if (subscribers.ContainsKey(action))
        subscribers[action].Add(item)
      else
        subscribers[action] = List([item])
    }
    
    subscribe(items : IEnumerable[ToolStripItem], action : void -> void) : void
    {
      items.Iter(subscribe(_, action))
    }
    #endregion
    
    initToolbarAndMenu() : void 
    {
      subscribe([newToolStripButton, newToolStripMenuItem], newFile);
      subscribe([openToolStripButton, openToolStripMenuItem], openFile);
      subscribe([saveToolStripButton, saveToolStripMenuItem], saveFile);
      subscribe(saveAsToolStripMenuItem, saveFileAs);
      subscribe(exitToolStripMenuItem, exit);
      
      Closing += (_, args) =>
      {
        args.Cancel = true;
        trySaveBeforeAction(() => {args.Cancel = false;})
      }

      subscribe(runToolStripMenuItem, runCode);

      subscribe(undoToolStripMenuItem, constructEditorAction(Actions.Undo()));
      subscribe(redoToolStripMenuItem, constructEditorAction(Actions.Redo()));
      subscribe([cutToolStripButton, cutToolStripMenuItem], constructEditorAction(Actions.Cut()));
      subscribe([copyToolStripButton, copyToolStripMenuItem], constructEditorAction(Actions.Copy()));
      subscribe([pasteToolStripButton, pasteToolStripMenuItem], constructEditorAction(Actions.Paste()));
     
      aboutToolStripMenuItem.Enabled = false;
    }
    
    initCompiler() : void 
    {
        def searchPaths = [@"%Nemerle%", @"%ProgramFiles%\Nemerle"];
        
        def isCorrectPath(path)
        {
            Directory.Exists(path) && File.Exists(Path.Combine(path, "ncc.exe"))
        }
        
        nemerlePath = searchPaths
          .Map(Environment.ExpandEnvironmentVariables)
          .FirstOrDefault(isCorrectPath);
        
        when (String.IsNullOrEmpty(nemerlePath))
          _ = MessageBox.Show(
                "Nemerle not found. Set Nemerle environment variable or install nemerle into Program Files\\Nemerle");
    }
    
    private initEditor() : void
    {
        codeEditor.Document.HighlightingStrategy = GetHighlightingStrategy();
        codeEditor.Document.DocumentChanged += (_, _) =>
        {
            isDirty = true;
        };
    }

    private initFileBrowser() : void
    {
        def snippetsCollection = SnippetCollection("Samples", "Samples");

        fileBrowser.Nodes.Clear();
        def collectionNode = fileBrowser.Nodes.Add(snippetsCollection.Title);
        def baseDirectory = AppDomain.CurrentDomain.BaseDirectory;

        snippetsCollection.ForEachFile(baseDirectory, file =>
        {
            def node = collectionNode.Nodes.Add(Path.GetFileNameWithoutExtension(file));
            node.ToolTipText = file;
            node.Tag = file;
        });

        collectionNode.Expand();
    }
  
    private fileBrowser_NodeMouseClick (_ : object,  e : System.Windows.Forms.TreeNodeMouseClickEventArgs) : void
    {
      match (e.Node.Tag :> string)
      {
        | null => ()
        | fileName => loadFile(fileName);
      }
    }
    
    loadFile(fileName : string) : void 
    {
        codeEditor.LoadFile(fileName);
        codeEditor.Document.HighlightingStrategy = GetHighlightingStrategy();
        currentFileName = fileName;
        isDirty = false;
    }

    updateTitle() : void 
    {
      def dirty = if (isDirty) "*" else "";
      
      def (fileName, separator) = match (currentFileName)
      {
        | null => ("", "")
        | path => (Path.GetFileName(path), " - ")
      }
      
      Text = $"$(dirty)$(fileName)$(separator)Nemerle Pad";
    }
    
    GetHighlightingStrategy() : IHighlightingStrategy 
    {
      HighlightingStrategyFactory.CreateHighlightingStrategy("C#");
    }
    
    
    #region Menu commands
    openFile() : void
    {
      def open() 
      {
        match (openFileDialog1.ShowDialog())
        {
          | OK => 
            currentFileName = openFileDialog1.FileName;
            codeEditor.LoadFile(currentFileName);
            isDirty = false;
          | Cancel => ();
          | _ => throw ArgumentException()
        }
      }
      
      trySaveBeforeAction(open)
    }

    trySaveBeforeAction(action : void -> void) : void
    {
      if (isDirty)
      {
        match (MessageBox.Show("File changed, save?", "File changes may be lost", MessageBoxButtons.YesNoCancel))
        {
          | Yes => 
            saveFile();
            action();
          | No => 
            action();
          | Cancel => ();
          | _ => throw ArgumentException()
        }
      }
      else
        action()
    }
    
    newFile() : void
    {
      def newFile()
      {
        // isnt clear editor api?
        doEditorAction(Actions.SelectWholeDocument());
        doEditorAction(Actions.Delete());
        
        currentFileName = null;
        isDirty = false;
      }
      
      trySaveBeforeAction(newFile)
    }

    saveFile() : void
    {
      if (currentFileName == null)
        saveFileAs()
      else
      {
        codeEditor.SaveFile(currentFileName);
        isDirty = false;
      }
    }

    saveFileAs() : void
    {
      saveFileDialog1.FileName = match (currentFileName)
      {
        | null => ""
        | name => name
      }
        
      match (saveFileDialog1.ShowDialog())
      {
        | OK => 
          codeEditor.SaveFile(saveFileDialog1.FileName);
          currentFileName = saveFileDialog1.FileName;
          isDirty = false;
        | Cancel => ();
        | _ => throw ArgumentException()
      }
    }

    exit() : void
    {
      trySaveBeforeAction(Close);
    }
    
    

    constructEditorAction(action : Actions.IEditAction) : void -> void
    {
      () => doEditorAction(action)
    }
    
    doEditorAction(action : Actions.IEditAction) : void
    {
      def editor = codeEditor;
			def area = editor.ActiveTextAreaControl.TextArea;
			editor.BeginUpdate();
			
			try 
			{
				lock (editor.Document) 
				{
					action.Execute(area);
					when (area.SelectionManager.HasSomethingSelected && area.AutoClearSelection /*&& caretchanged*/) 
					{
						when (area.Document.TextEditorProperties.DocumentSelectionMode == DocumentSelectionMode.Normal) 
						{
							area.SelectionManager.ClearSelection();
						}
					}
				}
			} 
			finally 
			{
			  editor.EndUpdate();
				area.Caret.UpdateCaretPosition();
			}
    }
    
    runCode() : void
    {
      def (fileName, isTemp) = match (currentFileName)
      {
        | null => 
          (Path.GetTempFileName(), true);
        | some => (some, false)
      }
      
      def assemblyFullName = Assembly.GetExecutingAssembly().FullName;
      def domain = AppDomain.CreateDomain(assemblyFullName);
      
      try
      {
        codeEditor.SaveFile(fileName);
        
        unless (isTemp)
          isDirty = false;
        
        
        def runner = domain
          .CreateInstanceAndUnwrap(assemblyFullName, typeof(AppRunner).FullName) :> AppRunner;
        
        runner.Setup(nemerlePath, CompilerType.Managed);

        def result = runner.CompileAndRun(FileInfo(fileName));
        
        def logFileName = if (isTemp)
            "snippet.n"
          else
            Path.GetFileName(fileName);
        
        def escapedName = Regex.Escape(fileName);

        def result = Regex
          .Replace(result, $"^$(escapedName)", logFileName, RegexOptions.Multiline);
          
        outputTextBox.Text = result;
      }
      catch
      {
        | e =>
          outputTextBox.Text = e.ToString()
      }
      finally
      {
        AppDomain.Unload(domain);
        when (isTemp) File.Delete(fileName)
      }
    }
    #endregion
  }
}
